// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package cart

//go:generate minimock -i route256/cart/internal/usecases/cart.storage -o storage_mock_test.go -n StorageMock -p cart

import (
	cartDto "route256/cart/internal/usecases/cart/dto"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorageMock implements storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(userID cartDto.UserID, skuID cartDto.SkuID, quantity uint32) (err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(userID cartDto.UserID, skuID cartDto.SkuID, quantity uint32)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mStorageMockAddItem

	funcDeleteItem          func(userID cartDto.UserID, skuID cartDto.SkuID) (err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(userID cartDto.UserID, skuID cartDto.SkuID)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mStorageMockDeleteItem

	funcDeleteUser          func(userID cartDto.UserID) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(userID cartDto.UserID)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mStorageMockDeleteUser

	funcGetItem          func(userID cartDto.UserID, skuID cartDto.SkuID) (quantity uint32, found bool)
	funcGetItemOrigin    string
	inspectFuncGetItem   func(userID cartDto.UserID, skuID cartDto.SkuID)
	afterGetItemCounter  uint64
	beforeGetItemCounter uint64
	GetItemMock          mStorageMockGetItem

	funcGetItems          func(userID cartDto.UserID) (ia1 []cartDto.Item, err error)
	funcGetItemsOrigin    string
	inspectFuncGetItems   func(userID cartDto.UserID)
	afterGetItemsCounter  uint64
	beforeGetItemsCounter uint64
	GetItemsMock          mStorageMockGetItems
}

// NewStorageMock returns a mock for storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mStorageMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*StorageMockAddItemParams{}

	m.DeleteItemMock = mStorageMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*StorageMockDeleteItemParams{}

	m.DeleteUserMock = mStorageMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*StorageMockDeleteUserParams{}

	m.GetItemMock = mStorageMockGetItem{mock: m}
	m.GetItemMock.callArgs = []*StorageMockGetItemParams{}

	m.GetItemsMock = mStorageMockGetItems{mock: m}
	m.GetItemsMock.callArgs = []*StorageMockGetItemsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockAddItem struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockAddItemExpectation
	expectations       []*StorageMockAddItemExpectation

	callArgs []*StorageMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockAddItemExpectation specifies expectation struct of the storage.AddItem
type StorageMockAddItemExpectation struct {
	mock               *StorageMock
	params             *StorageMockAddItemParams
	paramPtrs          *StorageMockAddItemParamPtrs
	expectationOrigins StorageMockAddItemExpectationOrigins
	results            *StorageMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockAddItemParams contains parameters of the storage.AddItem
type StorageMockAddItemParams struct {
	userID   cartDto.UserID
	skuID    cartDto.SkuID
	quantity uint32
}

// StorageMockAddItemParamPtrs contains pointers to parameters of the storage.AddItem
type StorageMockAddItemParamPtrs struct {
	userID   *cartDto.UserID
	skuID    *cartDto.SkuID
	quantity *uint32
}

// StorageMockAddItemResults contains results of the storage.AddItem
type StorageMockAddItemResults struct {
	err error
}

// StorageMockAddItemOrigins contains origins of expectations of the storage.AddItem
type StorageMockAddItemExpectationOrigins struct {
	origin         string
	originUserID   string
	originSkuID    string
	originQuantity string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mStorageMockAddItem) Optional() *mStorageMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for storage.AddItem
func (mmAddItem *mStorageMockAddItem) Expect(userID cartDto.UserID, skuID cartDto.SkuID, quantity uint32) *mStorageMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &StorageMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &StorageMockAddItemParams{userID, skuID, quantity}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectUserIDParam1 sets up expected param userID for storage.AddItem
func (mmAddItem *mStorageMockAddItem) ExpectUserIDParam1(userID cartDto.UserID) *mStorageMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &StorageMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &StorageMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.userID = &userID
	mmAddItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectSkuIDParam2 sets up expected param skuID for storage.AddItem
func (mmAddItem *mStorageMockAddItem) ExpectSkuIDParam2(skuID cartDto.SkuID) *mStorageMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &StorageMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &StorageMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.skuID = &skuID
	mmAddItem.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectQuantityParam3 sets up expected param quantity for storage.AddItem
func (mmAddItem *mStorageMockAddItem) ExpectQuantityParam3(quantity uint32) *mStorageMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &StorageMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &StorageMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.quantity = &quantity
	mmAddItem.defaultExpectation.expectationOrigins.originQuantity = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the storage.AddItem
func (mmAddItem *mStorageMockAddItem) Inspect(f func(userID cartDto.UserID, skuID cartDto.SkuID, quantity uint32)) *mStorageMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for StorageMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by storage.AddItem
func (mmAddItem *mStorageMockAddItem) Return(err error) *StorageMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &StorageMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &StorageMockAddItemResults{err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the storage.AddItem method
func (mmAddItem *mStorageMockAddItem) Set(f func(userID cartDto.UserID, skuID cartDto.SkuID, quantity uint32) (err error)) *StorageMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the storage.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the storage.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the storage.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mStorageMockAddItem) When(userID cartDto.UserID, skuID cartDto.SkuID, quantity uint32) *StorageMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("StorageMock.AddItem mock is already set by Set")
	}

	expectation := &StorageMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &StorageMockAddItemParams{userID, skuID, quantity},
		expectationOrigins: StorageMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up storage.AddItem return parameters for the expectation previously defined by the When method
func (e *StorageMockAddItemExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockAddItemResults{err}
	return e.mock
}

// Times sets number of times storage.AddItem should be invoked
func (mmAddItem *mStorageMockAddItem) Times(n uint64) *mStorageMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of StorageMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mStorageMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements storage
func (mmAddItem *StorageMock) AddItem(userID cartDto.UserID, skuID cartDto.SkuID, quantity uint32) (err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(userID, skuID, quantity)
	}

	mm_params := StorageMockAddItemParams{userID, skuID, quantity}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := StorageMockAddItemParams{userID, skuID, quantity}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddItem.t.Errorf("StorageMock.AddItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmAddItem.t.Errorf("StorageMock.AddItem got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

			if mm_want_ptrs.quantity != nil && !minimock.Equal(*mm_want_ptrs.quantity, mm_got.quantity) {
				mmAddItem.t.Errorf("StorageMock.AddItem got unexpected parameter quantity, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originQuantity, *mm_want_ptrs.quantity, mm_got.quantity, minimock.Diff(*mm_want_ptrs.quantity, mm_got.quantity))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("StorageMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the StorageMock.AddItem")
		}
		return (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(userID, skuID, quantity)
	}
	mmAddItem.t.Fatalf("Unexpected call to StorageMock.AddItem. %v %v %v", userID, skuID, quantity)
	return
}

// AddItemAfterCounter returns a count of finished StorageMock.AddItem invocations
func (mmAddItem *StorageMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of StorageMock.AddItem invocations
func (mmAddItem *StorageMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mStorageMockAddItem) Calls() []*StorageMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*StorageMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *StorageMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mStorageMockDeleteItem struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockDeleteItemExpectation
	expectations       []*StorageMockDeleteItemExpectation

	callArgs []*StorageMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockDeleteItemExpectation specifies expectation struct of the storage.DeleteItem
type StorageMockDeleteItemExpectation struct {
	mock               *StorageMock
	params             *StorageMockDeleteItemParams
	paramPtrs          *StorageMockDeleteItemParamPtrs
	expectationOrigins StorageMockDeleteItemExpectationOrigins
	results            *StorageMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockDeleteItemParams contains parameters of the storage.DeleteItem
type StorageMockDeleteItemParams struct {
	userID cartDto.UserID
	skuID  cartDto.SkuID
}

// StorageMockDeleteItemParamPtrs contains pointers to parameters of the storage.DeleteItem
type StorageMockDeleteItemParamPtrs struct {
	userID *cartDto.UserID
	skuID  *cartDto.SkuID
}

// StorageMockDeleteItemResults contains results of the storage.DeleteItem
type StorageMockDeleteItemResults struct {
	err error
}

// StorageMockDeleteItemOrigins contains origins of expectations of the storage.DeleteItem
type StorageMockDeleteItemExpectationOrigins struct {
	origin       string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mStorageMockDeleteItem) Optional() *mStorageMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for storage.DeleteItem
func (mmDeleteItem *mStorageMockDeleteItem) Expect(userID cartDto.UserID, skuID cartDto.SkuID) *mStorageMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("StorageMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &StorageMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("StorageMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &StorageMockDeleteItemParams{userID, skuID}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectUserIDParam1 sets up expected param userID for storage.DeleteItem
func (mmDeleteItem *mStorageMockDeleteItem) ExpectUserIDParam1(userID cartDto.UserID) *mStorageMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("StorageMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &StorageMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("StorageMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &StorageMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteItem
}

// ExpectSkuIDParam2 sets up expected param skuID for storage.DeleteItem
func (mmDeleteItem *mStorageMockDeleteItem) ExpectSkuIDParam2(skuID cartDto.SkuID) *mStorageMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("StorageMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &StorageMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("StorageMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &StorageMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.skuID = &skuID
	mmDeleteItem.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the storage.DeleteItem
func (mmDeleteItem *mStorageMockDeleteItem) Inspect(f func(userID cartDto.UserID, skuID cartDto.SkuID)) *mStorageMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for StorageMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by storage.DeleteItem
func (mmDeleteItem *mStorageMockDeleteItem) Return(err error) *StorageMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("StorageMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &StorageMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &StorageMockDeleteItemResults{err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the storage.DeleteItem method
func (mmDeleteItem *mStorageMockDeleteItem) Set(f func(userID cartDto.UserID, skuID cartDto.SkuID) (err error)) *StorageMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the storage.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the storage.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the storage.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mStorageMockDeleteItem) When(userID cartDto.UserID, skuID cartDto.SkuID) *StorageMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("StorageMock.DeleteItem mock is already set by Set")
	}

	expectation := &StorageMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &StorageMockDeleteItemParams{userID, skuID},
		expectationOrigins: StorageMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up storage.DeleteItem return parameters for the expectation previously defined by the When method
func (e *StorageMockDeleteItemExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockDeleteItemResults{err}
	return e.mock
}

// Times sets number of times storage.DeleteItem should be invoked
func (mmDeleteItem *mStorageMockDeleteItem) Times(n uint64) *mStorageMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of StorageMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mStorageMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements storage
func (mmDeleteItem *StorageMock) DeleteItem(userID cartDto.UserID, skuID cartDto.SkuID) (err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(userID, skuID)
	}

	mm_params := StorageMockDeleteItemParams{userID, skuID}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := StorageMockDeleteItemParams{userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteItem.t.Errorf("StorageMock.DeleteItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmDeleteItem.t.Errorf("StorageMock.DeleteItem got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("StorageMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the StorageMock.DeleteItem")
		}
		return (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(userID, skuID)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to StorageMock.DeleteItem. %v %v", userID, skuID)
	return
}

// DeleteItemAfterCounter returns a count of finished StorageMock.DeleteItem invocations
func (mmDeleteItem *StorageMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of StorageMock.DeleteItem invocations
func (mmDeleteItem *StorageMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mStorageMockDeleteItem) Calls() []*StorageMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*StorageMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *StorageMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mStorageMockDeleteUser struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockDeleteUserExpectation
	expectations       []*StorageMockDeleteUserExpectation

	callArgs []*StorageMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockDeleteUserExpectation specifies expectation struct of the storage.DeleteUser
type StorageMockDeleteUserExpectation struct {
	mock               *StorageMock
	params             *StorageMockDeleteUserParams
	paramPtrs          *StorageMockDeleteUserParamPtrs
	expectationOrigins StorageMockDeleteUserExpectationOrigins
	results            *StorageMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockDeleteUserParams contains parameters of the storage.DeleteUser
type StorageMockDeleteUserParams struct {
	userID cartDto.UserID
}

// StorageMockDeleteUserParamPtrs contains pointers to parameters of the storage.DeleteUser
type StorageMockDeleteUserParamPtrs struct {
	userID *cartDto.UserID
}

// StorageMockDeleteUserResults contains results of the storage.DeleteUser
type StorageMockDeleteUserResults struct {
	err error
}

// StorageMockDeleteUserOrigins contains origins of expectations of the storage.DeleteUser
type StorageMockDeleteUserExpectationOrigins struct {
	origin       string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mStorageMockDeleteUser) Optional() *mStorageMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for storage.DeleteUser
func (mmDeleteUser *mStorageMockDeleteUser) Expect(userID cartDto.UserID) *mStorageMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("StorageMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &StorageMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("StorageMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &StorageMockDeleteUserParams{userID}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectUserIDParam1 sets up expected param userID for storage.DeleteUser
func (mmDeleteUser *mStorageMockDeleteUser) ExpectUserIDParam1(userID cartDto.UserID) *mStorageMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("StorageMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &StorageMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("StorageMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &StorageMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteUser.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the storage.DeleteUser
func (mmDeleteUser *mStorageMockDeleteUser) Inspect(f func(userID cartDto.UserID)) *mStorageMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for StorageMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by storage.DeleteUser
func (mmDeleteUser *mStorageMockDeleteUser) Return(err error) *StorageMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("StorageMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &StorageMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &StorageMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the storage.DeleteUser method
func (mmDeleteUser *mStorageMockDeleteUser) Set(f func(userID cartDto.UserID) (err error)) *StorageMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the storage.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the storage.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the storage.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mStorageMockDeleteUser) When(userID cartDto.UserID) *StorageMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("StorageMock.DeleteUser mock is already set by Set")
	}

	expectation := &StorageMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &StorageMockDeleteUserParams{userID},
		expectationOrigins: StorageMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up storage.DeleteUser return parameters for the expectation previously defined by the When method
func (e *StorageMockDeleteUserExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times storage.DeleteUser should be invoked
func (mmDeleteUser *mStorageMockDeleteUser) Times(n uint64) *mStorageMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of StorageMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mStorageMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements storage
func (mmDeleteUser *StorageMock) DeleteUser(userID cartDto.UserID) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(userID)
	}

	mm_params := StorageMockDeleteUserParams{userID}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := StorageMockDeleteUserParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteUser.t.Errorf("StorageMock.DeleteUser got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("StorageMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the StorageMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(userID)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to StorageMock.DeleteUser. %v", userID)
	return
}

// DeleteUserAfterCounter returns a count of finished StorageMock.DeleteUser invocations
func (mmDeleteUser *StorageMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of StorageMock.DeleteUser invocations
func (mmDeleteUser *StorageMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mStorageMockDeleteUser) Calls() []*StorageMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*StorageMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *StorageMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mStorageMockGetItem struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetItemExpectation
	expectations       []*StorageMockGetItemExpectation

	callArgs []*StorageMockGetItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetItemExpectation specifies expectation struct of the storage.GetItem
type StorageMockGetItemExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetItemParams
	paramPtrs          *StorageMockGetItemParamPtrs
	expectationOrigins StorageMockGetItemExpectationOrigins
	results            *StorageMockGetItemResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetItemParams contains parameters of the storage.GetItem
type StorageMockGetItemParams struct {
	userID cartDto.UserID
	skuID  cartDto.SkuID
}

// StorageMockGetItemParamPtrs contains pointers to parameters of the storage.GetItem
type StorageMockGetItemParamPtrs struct {
	userID *cartDto.UserID
	skuID  *cartDto.SkuID
}

// StorageMockGetItemResults contains results of the storage.GetItem
type StorageMockGetItemResults struct {
	quantity uint32
	found    bool
}

// StorageMockGetItemOrigins contains origins of expectations of the storage.GetItem
type StorageMockGetItemExpectationOrigins struct {
	origin       string
	originUserID string
	originSkuID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItem *mStorageMockGetItem) Optional() *mStorageMockGetItem {
	mmGetItem.optional = true
	return mmGetItem
}

// Expect sets up expected params for storage.GetItem
func (mmGetItem *mStorageMockGetItem) Expect(userID cartDto.UserID, skuID cartDto.SkuID) *mStorageMockGetItem {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("StorageMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &StorageMockGetItemExpectation{}
	}

	if mmGetItem.defaultExpectation.paramPtrs != nil {
		mmGetItem.mock.t.Fatalf("StorageMock.GetItem mock is already set by ExpectParams functions")
	}

	mmGetItem.defaultExpectation.params = &StorageMockGetItemParams{userID, skuID}
	mmGetItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItem.expectations {
		if minimock.Equal(e.params, mmGetItem.defaultExpectation.params) {
			mmGetItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItem.defaultExpectation.params)
		}
	}

	return mmGetItem
}

// ExpectUserIDParam1 sets up expected param userID for storage.GetItem
func (mmGetItem *mStorageMockGetItem) ExpectUserIDParam1(userID cartDto.UserID) *mStorageMockGetItem {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("StorageMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &StorageMockGetItemExpectation{}
	}

	if mmGetItem.defaultExpectation.params != nil {
		mmGetItem.mock.t.Fatalf("StorageMock.GetItem mock is already set by Expect")
	}

	if mmGetItem.defaultExpectation.paramPtrs == nil {
		mmGetItem.defaultExpectation.paramPtrs = &StorageMockGetItemParamPtrs{}
	}
	mmGetItem.defaultExpectation.paramPtrs.userID = &userID
	mmGetItem.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetItem
}

// ExpectSkuIDParam2 sets up expected param skuID for storage.GetItem
func (mmGetItem *mStorageMockGetItem) ExpectSkuIDParam2(skuID cartDto.SkuID) *mStorageMockGetItem {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("StorageMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &StorageMockGetItemExpectation{}
	}

	if mmGetItem.defaultExpectation.params != nil {
		mmGetItem.mock.t.Fatalf("StorageMock.GetItem mock is already set by Expect")
	}

	if mmGetItem.defaultExpectation.paramPtrs == nil {
		mmGetItem.defaultExpectation.paramPtrs = &StorageMockGetItemParamPtrs{}
	}
	mmGetItem.defaultExpectation.paramPtrs.skuID = &skuID
	mmGetItem.defaultExpectation.expectationOrigins.originSkuID = minimock.CallerInfo(1)

	return mmGetItem
}

// Inspect accepts an inspector function that has same arguments as the storage.GetItem
func (mmGetItem *mStorageMockGetItem) Inspect(f func(userID cartDto.UserID, skuID cartDto.SkuID)) *mStorageMockGetItem {
	if mmGetItem.mock.inspectFuncGetItem != nil {
		mmGetItem.mock.t.Fatalf("Inspect function is already set for StorageMock.GetItem")
	}

	mmGetItem.mock.inspectFuncGetItem = f

	return mmGetItem
}

// Return sets up results that will be returned by storage.GetItem
func (mmGetItem *mStorageMockGetItem) Return(quantity uint32, found bool) *StorageMock {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("StorageMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &StorageMockGetItemExpectation{mock: mmGetItem.mock}
	}
	mmGetItem.defaultExpectation.results = &StorageMockGetItemResults{quantity, found}
	mmGetItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItem.mock
}

// Set uses given function f to mock the storage.GetItem method
func (mmGetItem *mStorageMockGetItem) Set(f func(userID cartDto.UserID, skuID cartDto.SkuID) (quantity uint32, found bool)) *StorageMock {
	if mmGetItem.defaultExpectation != nil {
		mmGetItem.mock.t.Fatalf("Default expectation is already set for the storage.GetItem method")
	}

	if len(mmGetItem.expectations) > 0 {
		mmGetItem.mock.t.Fatalf("Some expectations are already set for the storage.GetItem method")
	}

	mmGetItem.mock.funcGetItem = f
	mmGetItem.mock.funcGetItemOrigin = minimock.CallerInfo(1)
	return mmGetItem.mock
}

// When sets expectation for the storage.GetItem which will trigger the result defined by the following
// Then helper
func (mmGetItem *mStorageMockGetItem) When(userID cartDto.UserID, skuID cartDto.SkuID) *StorageMockGetItemExpectation {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("StorageMock.GetItem mock is already set by Set")
	}

	expectation := &StorageMockGetItemExpectation{
		mock:               mmGetItem.mock,
		params:             &StorageMockGetItemParams{userID, skuID},
		expectationOrigins: StorageMockGetItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItem.expectations = append(mmGetItem.expectations, expectation)
	return expectation
}

// Then sets up storage.GetItem return parameters for the expectation previously defined by the When method
func (e *StorageMockGetItemExpectation) Then(quantity uint32, found bool) *StorageMock {
	e.results = &StorageMockGetItemResults{quantity, found}
	return e.mock
}

// Times sets number of times storage.GetItem should be invoked
func (mmGetItem *mStorageMockGetItem) Times(n uint64) *mStorageMockGetItem {
	if n == 0 {
		mmGetItem.mock.t.Fatalf("Times of StorageMock.GetItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItem.expectedInvocations, n)
	mmGetItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItem
}

func (mmGetItem *mStorageMockGetItem) invocationsDone() bool {
	if len(mmGetItem.expectations) == 0 && mmGetItem.defaultExpectation == nil && mmGetItem.mock.funcGetItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItem.mock.afterGetItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItem implements storage
func (mmGetItem *StorageMock) GetItem(userID cartDto.UserID, skuID cartDto.SkuID) (quantity uint32, found bool) {
	mm_atomic.AddUint64(&mmGetItem.beforeGetItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItem.afterGetItemCounter, 1)

	mmGetItem.t.Helper()

	if mmGetItem.inspectFuncGetItem != nil {
		mmGetItem.inspectFuncGetItem(userID, skuID)
	}

	mm_params := StorageMockGetItemParams{userID, skuID}

	// Record call args
	mmGetItem.GetItemMock.mutex.Lock()
	mmGetItem.GetItemMock.callArgs = append(mmGetItem.GetItemMock.callArgs, &mm_params)
	mmGetItem.GetItemMock.mutex.Unlock()

	for _, e := range mmGetItem.GetItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.quantity, e.results.found
		}
	}

	if mmGetItem.GetItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItem.GetItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItem.GetItemMock.defaultExpectation.params
		mm_want_ptrs := mmGetItem.GetItemMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetItemParams{userID, skuID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetItem.t.Errorf("StorageMock.GetItem got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItem.GetItemMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.skuID != nil && !minimock.Equal(*mm_want_ptrs.skuID, mm_got.skuID) {
				mmGetItem.t.Errorf("StorageMock.GetItem got unexpected parameter skuID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItem.GetItemMock.defaultExpectation.expectationOrigins.originSkuID, *mm_want_ptrs.skuID, mm_got.skuID, minimock.Diff(*mm_want_ptrs.skuID, mm_got.skuID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItem.t.Errorf("StorageMock.GetItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItem.GetItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItem.GetItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItem.t.Fatal("No results are set for the StorageMock.GetItem")
		}
		return (*mm_results).quantity, (*mm_results).found
	}
	if mmGetItem.funcGetItem != nil {
		return mmGetItem.funcGetItem(userID, skuID)
	}
	mmGetItem.t.Fatalf("Unexpected call to StorageMock.GetItem. %v %v", userID, skuID)
	return
}

// GetItemAfterCounter returns a count of finished StorageMock.GetItem invocations
func (mmGetItem *StorageMock) GetItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItem.afterGetItemCounter)
}

// GetItemBeforeCounter returns a count of StorageMock.GetItem invocations
func (mmGetItem *StorageMock) GetItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItem.beforeGetItemCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItem *mStorageMockGetItem) Calls() []*StorageMockGetItemParams {
	mmGetItem.mutex.RLock()

	argCopy := make([]*StorageMockGetItemParams, len(mmGetItem.callArgs))
	copy(argCopy, mmGetItem.callArgs)

	mmGetItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemDone returns true if the count of the GetItem invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetItemDone() bool {
	if m.GetItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemMock.invocationsDone()
}

// MinimockGetItemInspect logs each unmet expectation
func (m *StorageMock) MinimockGetItemInspect() {
	for _, e := range m.GetItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemCounter := mm_atomic.LoadUint64(&m.afterGetItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemMock.defaultExpectation != nil && afterGetItemCounter < 1 {
		if m.GetItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetItem at\n%s", m.GetItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetItem at\n%s with params: %#v", m.GetItemMock.defaultExpectation.expectationOrigins.origin, *m.GetItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItem != nil && afterGetItemCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetItem at\n%s", m.funcGetItemOrigin)
	}

	if !m.GetItemMock.invocationsDone() && afterGetItemCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemMock.expectedInvocations), m.GetItemMock.expectedInvocationsOrigin, afterGetItemCounter)
	}
}

type mStorageMockGetItems struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetItemsExpectation
	expectations       []*StorageMockGetItemsExpectation

	callArgs []*StorageMockGetItemsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetItemsExpectation specifies expectation struct of the storage.GetItems
type StorageMockGetItemsExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetItemsParams
	paramPtrs          *StorageMockGetItemsParamPtrs
	expectationOrigins StorageMockGetItemsExpectationOrigins
	results            *StorageMockGetItemsResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetItemsParams contains parameters of the storage.GetItems
type StorageMockGetItemsParams struct {
	userID cartDto.UserID
}

// StorageMockGetItemsParamPtrs contains pointers to parameters of the storage.GetItems
type StorageMockGetItemsParamPtrs struct {
	userID *cartDto.UserID
}

// StorageMockGetItemsResults contains results of the storage.GetItems
type StorageMockGetItemsResults struct {
	ia1 []cartDto.Item
	err error
}

// StorageMockGetItemsOrigins contains origins of expectations of the storage.GetItems
type StorageMockGetItemsExpectationOrigins struct {
	origin       string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItems *mStorageMockGetItems) Optional() *mStorageMockGetItems {
	mmGetItems.optional = true
	return mmGetItems
}

// Expect sets up expected params for storage.GetItems
func (mmGetItems *mStorageMockGetItems) Expect(userID cartDto.UserID) *mStorageMockGetItems {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("StorageMock.GetItems mock is already set by Set")
	}

	if mmGetItems.defaultExpectation == nil {
		mmGetItems.defaultExpectation = &StorageMockGetItemsExpectation{}
	}

	if mmGetItems.defaultExpectation.paramPtrs != nil {
		mmGetItems.mock.t.Fatalf("StorageMock.GetItems mock is already set by ExpectParams functions")
	}

	mmGetItems.defaultExpectation.params = &StorageMockGetItemsParams{userID}
	mmGetItems.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItems.expectations {
		if minimock.Equal(e.params, mmGetItems.defaultExpectation.params) {
			mmGetItems.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItems.defaultExpectation.params)
		}
	}

	return mmGetItems
}

// ExpectUserIDParam1 sets up expected param userID for storage.GetItems
func (mmGetItems *mStorageMockGetItems) ExpectUserIDParam1(userID cartDto.UserID) *mStorageMockGetItems {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("StorageMock.GetItems mock is already set by Set")
	}

	if mmGetItems.defaultExpectation == nil {
		mmGetItems.defaultExpectation = &StorageMockGetItemsExpectation{}
	}

	if mmGetItems.defaultExpectation.params != nil {
		mmGetItems.mock.t.Fatalf("StorageMock.GetItems mock is already set by Expect")
	}

	if mmGetItems.defaultExpectation.paramPtrs == nil {
		mmGetItems.defaultExpectation.paramPtrs = &StorageMockGetItemsParamPtrs{}
	}
	mmGetItems.defaultExpectation.paramPtrs.userID = &userID
	mmGetItems.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmGetItems
}

// Inspect accepts an inspector function that has same arguments as the storage.GetItems
func (mmGetItems *mStorageMockGetItems) Inspect(f func(userID cartDto.UserID)) *mStorageMockGetItems {
	if mmGetItems.mock.inspectFuncGetItems != nil {
		mmGetItems.mock.t.Fatalf("Inspect function is already set for StorageMock.GetItems")
	}

	mmGetItems.mock.inspectFuncGetItems = f

	return mmGetItems
}

// Return sets up results that will be returned by storage.GetItems
func (mmGetItems *mStorageMockGetItems) Return(ia1 []cartDto.Item, err error) *StorageMock {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("StorageMock.GetItems mock is already set by Set")
	}

	if mmGetItems.defaultExpectation == nil {
		mmGetItems.defaultExpectation = &StorageMockGetItemsExpectation{mock: mmGetItems.mock}
	}
	mmGetItems.defaultExpectation.results = &StorageMockGetItemsResults{ia1, err}
	mmGetItems.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItems.mock
}

// Set uses given function f to mock the storage.GetItems method
func (mmGetItems *mStorageMockGetItems) Set(f func(userID cartDto.UserID) (ia1 []cartDto.Item, err error)) *StorageMock {
	if mmGetItems.defaultExpectation != nil {
		mmGetItems.mock.t.Fatalf("Default expectation is already set for the storage.GetItems method")
	}

	if len(mmGetItems.expectations) > 0 {
		mmGetItems.mock.t.Fatalf("Some expectations are already set for the storage.GetItems method")
	}

	mmGetItems.mock.funcGetItems = f
	mmGetItems.mock.funcGetItemsOrigin = minimock.CallerInfo(1)
	return mmGetItems.mock
}

// When sets expectation for the storage.GetItems which will trigger the result defined by the following
// Then helper
func (mmGetItems *mStorageMockGetItems) When(userID cartDto.UserID) *StorageMockGetItemsExpectation {
	if mmGetItems.mock.funcGetItems != nil {
		mmGetItems.mock.t.Fatalf("StorageMock.GetItems mock is already set by Set")
	}

	expectation := &StorageMockGetItemsExpectation{
		mock:               mmGetItems.mock,
		params:             &StorageMockGetItemsParams{userID},
		expectationOrigins: StorageMockGetItemsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItems.expectations = append(mmGetItems.expectations, expectation)
	return expectation
}

// Then sets up storage.GetItems return parameters for the expectation previously defined by the When method
func (e *StorageMockGetItemsExpectation) Then(ia1 []cartDto.Item, err error) *StorageMock {
	e.results = &StorageMockGetItemsResults{ia1, err}
	return e.mock
}

// Times sets number of times storage.GetItems should be invoked
func (mmGetItems *mStorageMockGetItems) Times(n uint64) *mStorageMockGetItems {
	if n == 0 {
		mmGetItems.mock.t.Fatalf("Times of StorageMock.GetItems mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItems.expectedInvocations, n)
	mmGetItems.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItems
}

func (mmGetItems *mStorageMockGetItems) invocationsDone() bool {
	if len(mmGetItems.expectations) == 0 && mmGetItems.defaultExpectation == nil && mmGetItems.mock.funcGetItems == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItems.mock.afterGetItemsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItems.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItems implements storage
func (mmGetItems *StorageMock) GetItems(userID cartDto.UserID) (ia1 []cartDto.Item, err error) {
	mm_atomic.AddUint64(&mmGetItems.beforeGetItemsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItems.afterGetItemsCounter, 1)

	mmGetItems.t.Helper()

	if mmGetItems.inspectFuncGetItems != nil {
		mmGetItems.inspectFuncGetItems(userID)
	}

	mm_params := StorageMockGetItemsParams{userID}

	// Record call args
	mmGetItems.GetItemsMock.mutex.Lock()
	mmGetItems.GetItemsMock.callArgs = append(mmGetItems.GetItemsMock.callArgs, &mm_params)
	mmGetItems.GetItemsMock.mutex.Unlock()

	for _, e := range mmGetItems.GetItemsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ia1, e.results.err
		}
	}

	if mmGetItems.GetItemsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItems.GetItemsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItems.GetItemsMock.defaultExpectation.params
		mm_want_ptrs := mmGetItems.GetItemsMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetItemsParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmGetItems.t.Errorf("StorageMock.GetItems got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItems.GetItemsMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItems.t.Errorf("StorageMock.GetItems got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItems.GetItemsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItems.GetItemsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItems.t.Fatal("No results are set for the StorageMock.GetItems")
		}
		return (*mm_results).ia1, (*mm_results).err
	}
	if mmGetItems.funcGetItems != nil {
		return mmGetItems.funcGetItems(userID)
	}
	mmGetItems.t.Fatalf("Unexpected call to StorageMock.GetItems. %v", userID)
	return
}

// GetItemsAfterCounter returns a count of finished StorageMock.GetItems invocations
func (mmGetItems *StorageMock) GetItemsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItems.afterGetItemsCounter)
}

// GetItemsBeforeCounter returns a count of StorageMock.GetItems invocations
func (mmGetItems *StorageMock) GetItemsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItems.beforeGetItemsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetItems.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItems *mStorageMockGetItems) Calls() []*StorageMockGetItemsParams {
	mmGetItems.mutex.RLock()

	argCopy := make([]*StorageMockGetItemsParams, len(mmGetItems.callArgs))
	copy(argCopy, mmGetItems.callArgs)

	mmGetItems.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsDone returns true if the count of the GetItems invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetItemsDone() bool {
	if m.GetItemsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemsMock.invocationsDone()
}

// MinimockGetItemsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetItemsInspect() {
	for _, e := range m.GetItemsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetItems at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemsCounter := mm_atomic.LoadUint64(&m.afterGetItemsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsMock.defaultExpectation != nil && afterGetItemsCounter < 1 {
		if m.GetItemsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetItems at\n%s", m.GetItemsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetItems at\n%s with params: %#v", m.GetItemsMock.defaultExpectation.expectationOrigins.origin, *m.GetItemsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItems != nil && afterGetItemsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetItems at\n%s", m.funcGetItemsOrigin)
	}

	if !m.GetItemsMock.invocationsDone() && afterGetItemsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetItems at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemsMock.expectedInvocations), m.GetItemsMock.expectedInvocationsOrigin, afterGetItemsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetItemInspect()

			m.MinimockGetItemsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetItemDone() &&
		m.MinimockGetItemsDone()
}
